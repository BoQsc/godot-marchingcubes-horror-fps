[gd_scene load_steps=20 format=3 uid="uid://c2pp8ci31jce2"]

[ext_resource type="AudioStream" uid="uid://i6o3hrbi2ac2" path="res://music/mysterious-dark-background-310162.mp3" id="1_i5arm"]
[ext_resource type="Script" path="res://Player.gd" id="1_player"]
[ext_resource type="PackedScene" uid="uid://bsiwysbjrs4v6" path="res://props/rigged_animated_cinematic_quality_tree_4.glb" id="1_wc5p8"]
[ext_resource type="Script" uid="uid://duyja5u7s3uww" path="res://TerrainManager.gd" id="2_terrain"]
[ext_resource type="PackedScene" uid="uid://b8j2q4x5y607" path="res://MarchingCubesChunk.tscn" id="3_chunk"]
[ext_resource type="PackedScene" uid="uid://o6xj2jdgavj" path="res://male_zombie.glb" id="3_jka67"]
[ext_resource type="PackedScene" uid="uid://1xh5cq6f56t3" path="res://heavy_pistol_animated.glb" id="4_r3fl7"]

[sub_resource type="GDScript" id="GDScript_jsk3o"]
script/source = "extends CharacterBody3D

# --- Settings ---
@export var gravity: float = 9.8

# --- References ---
# Finds the AnimationPlayer inside the new node name \"Sketchfab_Scene tree\"
@onready var anim_player = $\"Sketchfab_Scene tree\".find_child(\"AnimationPlayer\")

func _ready():
	if anim_player:
		# 1. SETUP ANIMATION
		# We check if the animation exists to prevent errors
		if anim_player.has_animation(\"MorphBake\"):
			var anim = anim_player.get_animation(\"MorphBake\")
			
			# Ensure it loops automatically (Standard linear loop)
			anim.loop_mode = Animation.LOOP_LINEAR
			
			# Play the specific animation
			anim_player.play(\"Scene\")
		
		# Sync animation to physics to prevent visual jitter
		anim_player.callback_mode_process = AnimationPlayer.ANIMATION_CALLBACK_MODE_PROCESS_PHYSICS

func _physics_process(delta):
	# 1. Gravity
	# We keep gravity so the tree sits properly on the ground/mesh
	if not is_on_floor():
		velocity.y -= gravity * delta
	else:
		velocity.y = -0.1 # Keep glued to floor to prevent micro-bouncing

	# 2. Ensure No Horizontal Movement
	# We explicitly zero this out to ensure it never slides
	velocity.x = 0
	velocity.z = 0

	# 3. Apply Physics
	move_and_slide()
	
	# Void Safety
	# If the map accidentally disappears or the tree falls through
	if global_position.y < -50:
		velocity = Vector3.ZERO
		global_position = Vector3(0, 5, 0)
"

[sub_resource type="CapsuleShape3D" id="CapsuleShape3D_wc5p8"]

[sub_resource type="ProceduralSkyMaterial" id="ProceduralSkyMaterial_4xowi"]
sky_horizon_color = Color(0.66224277, 0.6717428, 0.6867428, 1)
ground_horizon_color = Color(0.66224277, 0.6717428, 0.6867428, 1)

[sub_resource type="Sky" id="Sky_a202f"]
sky_material = SubResource("ProceduralSkyMaterial_4xowi")

[sub_resource type="Environment" id="Environment_noarx"]
background_mode = 2
sky = SubResource("Sky_a202f")
tonemap_mode = 2
glow_enabled = true

[sub_resource type="GDScript" id="GDScript_i5arm"]
script/source = "extends CharacterBody3D

# --- Settings ---
@export var move_speed: float = 1.0
@export var gravity: float = 9.8
@export var friction: float = 10.0

# --- References ---
@onready var anim_player = $\"Sketchfab_Scene zombie\".find_child(\"AnimationPlayer\")

# --- State ---
var current_state = \"IDLE\"
var wander_timer: float = 0.0

func _ready():
	# 1. SETUP NOSE (Re-added RayCast as it is more reliable for \"Walls\" than is_on_wall)
	# Using RayCast prevents the \"is_on_wall\" flicker if the mesh is bumpy.
	var wall_detector = RayCast3D.new()
	wall_detector.name = \"WallDetector\"
	add_child(wall_detector)
	wall_detector.position = Vector3(0, 1.0, 0.6) # Forward position
	wall_detector.enabled = true
	wall_detector.target_position = Vector3(0, 0, 1.0)

	if anim_player:
		anim_player.play(\"Take 001\")
		if anim_player.has_animation(\"Take 001\"):
			# CRITICAL: Turn OFF internal looping. We handle the math ourselves.
			anim_player.get_animation(\"Take 001\").loop_mode = Animation.LOOP_NONE
		
		# CRITICAL: Sync animation to physics (60 FPS) to stop visual vibration
		anim_player.callback_mode_process = AnimationPlayer.ANIMATION_CALLBACK_MODE_PROCESS_PHYSICS

	# Safety Start
	set_physics_process(false)
	await get_tree().create_timer(0.5).timeout
	set_physics_process(true)
	change_state(\"IDLE\")

func _physics_process(delta):
	# 1. Gravity (with Floor Snap)
	if not is_on_floor():
		velocity.y -= gravity * delta
	else:
		velocity.y = -0.1 # Keep him glued to floor

	# 2. SMOOTH ANIMATION LOOPING (The Twitch Fix)
	if anim_player:
		var t = anim_player.current_animation_position
		
		if current_state == \"IDLE\":
			# Idle Range: 0.0 to 1.0
			if t >= 1.0:
				# MATH FIX: Instead of seek(0.0), we keep the overflow.
				# If t is 1.02, we seek to 0.02. This keeps it smooth.
				anim_player.seek(t - 1.0)
				
		elif current_state == \"WALK\":
			# Walk Range: 1.0 to 2.0
			if t >= 2.0:
				# MATH FIX: If t is 2.02, we seek to 1.02.
				anim_player.seek(1.0 + (t - 2.0))

	# 3. MOVEMENT
	if current_state == \"IDLE\":
		velocity.x = move_toward(velocity.x, 0, friction * delta)
		velocity.z = move_toward(velocity.z, 0, friction * delta)
		
		wander_timer -= delta
		if wander_timer <= 0:
			pick_random_direction()
			change_state(\"WALK\")
			
	elif current_state == \"WALK\":
		var forward_dir = transform.basis.z.normalized()
		velocity.x = forward_dir.x * move_speed
		velocity.z = forward_dir.z * move_speed
		
		wander_timer -= delta
		
		# Check wall detector
		var wd = get_node_or_null(\"WallDetector\")
		if (wd and wd.is_colliding()) or wander_timer <= 0:
			change_state(\"IDLE\")

	move_and_slide()
	
	# Void Safety
	if global_position.y < -50:
		velocity = Vector3.ZERO
		global_position = Vector3(0, 5, 0)

func change_state(new_state):
	current_state = new_state
	
	if anim_player:
		# When switching states, we do a hard seek because the pose changes anyway
		if new_state == \"IDLE\": anim_player.seek(0.0)
		if new_state == \"WALK\": anim_player.seek(1.0)
		
	if new_state == \"IDLE\": wander_timer = randf_range(2.0, 4.0)
	if new_state == \"WALK\": wander_timer = randf_range(3.0, 6.0)

func pick_random_direction():
	rotate_y(deg_to_rad(randf_range(90, 270)))
"

[sub_resource type="CapsuleShape3D" id="CapsuleShape3D_jka67"]

[sub_resource type="CapsuleMesh" id="CapsuleMesh_noarx"]

[sub_resource type="CapsuleShape3D" id="CapsuleShape3D_a0tk4"]

[sub_resource type="GDScript" id="GDScript_jka67"]
script/source = "@tool
extends Camera3D

const MOUSE_SENSITIVITY = 0.002

func _get_configuration_warnings():
	var warnings = []
	
	if not get_parent() is CharacterBody3D:
		warnings.append(\"Requires CharacterBody3D as a parent of Camera3D\")
	
	return warnings

func _notification(what: int) -> void:
	if what == NOTIFICATION_PARENTED and Engine.is_editor_hint():
		call_deferred(\"update_configuration_warnings\")

func _ready() -> void:
	if Engine.is_editor_hint():
		update_configuration_warnings()
		return
	
	# Capture the mouse cursor for first-person controls
	Input.set_mouse_mode(Input.MOUSE_MODE_CAPTURED)

func _input(event: InputEvent) -> void:
	if Engine.is_editor_hint():
		return
		
	# Handle mouse look
	if event is InputEventMouseMotion and Input.get_mouse_mode() == Input.MOUSE_MODE_CAPTURED:
		# Rotate parent horizontally (yaw)
		get_parent().rotate_y(-event.relative.x * MOUSE_SENSITIVITY)
		
		# Rotate camera vertically (pitch)
		rotate_object_local(Vector3.RIGHT, -event.relative.y * MOUSE_SENSITIVITY)
		
		# Clamp vertical rotation to prevent flipping
		rotation.x = clamp(rotation.x, deg_to_rad(-90), deg_to_rad(90))

func _unhandled_input(event: InputEvent) -> void:
	if Engine.is_editor_hint():
		return
		
	# Toggle mouse capture when pressing Cancel (Esc)
	if event.is_action_pressed(\"ui_cancel\"):
		if Input.get_mouse_mode() == Input.MOUSE_MODE_CAPTURED:
			Input.set_mouse_mode(Input.MOUSE_MODE_VISIBLE)
		else:
			Input.set_mouse_mode(Input.MOUSE_MODE_CAPTURED)
			
	# Click to recapture mouse if visible
	if event is InputEventMouseButton and event.pressed:
		if Input.get_mouse_mode() == Input.MOUSE_MODE_VISIBLE:
			Input.set_mouse_mode(Input.MOUSE_MODE_CAPTURED)
"

[sub_resource type="GDScript" id="GDScript_r3fl7"]
script/source = "extends Node3D

# Preload resources to prevent lag spikes
const PISTOL_SOUND = preload(\"res://pistol-shot-233473.mp3\")
# Use preload for blocks too
const BLOCK_SCENE = preload(\"res://Block.tscn\")

# Reference to the AnimationPlayer child node
@onready var animation_player = $AnimationPlayer

# Variable to hold the dynamic audio player
var audio_player: AudioStreamPlayer3D

func _ready():
	# 1. Setup Audio
	audio_player = AudioStreamPlayer3D.new()
	add_child(audio_player)
	audio_player.stream = PISTOL_SOUND
	# Allow up to 5 overlapping sounds so rapid clicks don't cut off previous shots
	audio_player.max_polyphony = 5
	
	# 2. Setup Crosshair (UI)
	setup_crosshair()

func setup_crosshair():
	# Create a canvas layer so the UI sits above the 3D world
	var canvas = CanvasLayer.new()
	add_child(canvas)
	
	# Create a container to center the crosshair
	var center_cont = CenterContainer.new()
	center_cont.set_anchors_preset(Control.PRESET_FULL_RECT) # Fill screen
	center_cont.mouse_filter = Control.MOUSE_FILTER_IGNORE
	canvas.add_child(center_cont)
	
	# Create the actual crosshair dot
	var dot = ColorRect.new()
	dot.custom_minimum_size = Vector2(4, 4) # 4x4 pixel square
	dot.color = Color(1, 0, 0, 0.8) # Red with slight transparency
	dot.mouse_filter = Control.MOUSE_FILTER_IGNORE
	center_cont.add_child(dot)

func _input(event):
	# Check if the event is a Mouse Button event
	if event is InputEventMouseButton:
		if event.pressed:
			if event.button_index == MOUSE_BUTTON_LEFT:
				if Input.is_key_pressed(KEY_ALT):
					play_animation_segment()
					place_block() # Alt + Left Click to place object
				elif Input.is_key_pressed(KEY_SHIFT):
					play_animation_segment()
					fire_build(\"box\") # Shift + Left Click to place terrain block
				elif Input.is_key_pressed(KEY_CTRL):
					play_animation_segment()
					fire_build(\"sphere\") # Ctrl + Left Click to build organic
				else:
					play_animation_segment()
					fire_raycast() # Just Left Click to shoot
			elif event.button_index == MOUSE_BUTTON_RIGHT:
				play_animation_segment()
				if Input.is_key_pressed(KEY_ALT):
					remove_block() # Alt + Right Click to remove object
				elif Input.is_key_pressed(KEY_CTRL):
					fire_dig() # Ctrl + Right Click to dig terrain
				elif Input.is_key_pressed(KEY_SHIFT):
					fire_road_paint(1.0)
				# else: plain Right Click does nothing, freeing it up

func play_animation_segment():
	# check if the animation exists to avoid errors
	if animation_player and animation_player.has_animation(\"allanims\"):
		animation_player.stop()
		
		audio_player.play()
		animation_player.play(\"allanims\")
		
		# Create a temporary timer for 0.3 seconds and wait for it to finish
		await get_tree().create_timer(0.3).timeout
		
		# SAFETY CHECK: Ensure the node and player still exist after the wait
		if is_instance_valid(animation_player):
			animation_player.stop()

# Helper to find TerrainManager even if path changes
func get_terrain_manager():
	if has_node(\"/root/Node3D/TerrainManager\"):
		return get_node(\"/root/Node3D/TerrainManager\")
	return null

func fire_road_paint(amount):
	var camera = get_viewport().get_camera_3d()
	if not camera: return
	
	var center_screen = get_viewport().get_visible_rect().size / 2
	var from = camera.project_ray_origin(center_screen)
	var to = from + camera.project_ray_normal(center_screen) * 1000
	var space_state = get_world_3d().direct_space_state
	var query = PhysicsRayQueryParameters3D.create(from, to)
	var result = space_state.intersect_ray(query)
	
	if result:
		var tm = get_terrain_manager()
		if tm:
			tm.modify_road(result.position, amount, 4.0)
		
		spawn_hit_effect(result.position)

func fire_raycast():
	var camera = get_viewport().get_camera_3d()
	if not camera: return

	var center_screen = get_viewport().get_visible_rect().size / 2
	var from = camera.project_ray_origin(center_screen)
	var to = from + camera.project_ray_normal(center_screen) * 1000
	var space_state = get_world_3d().direct_space_state
	var query = PhysicsRayQueryParameters3D.create(from, to)
	var result = space_state.intersect_ray(query)
	
	if result:
		if result.collider.is_in_group(\"blocks\") and result.collider.has_method(\"take_damage\"):
			result.collider.take_damage(1)
		else:
			# Micro-digging on terrain
			var tm = get_terrain_manager()
			if tm:
				tm.modify_terrain(result.position, 2.0, \"sphere\", 0.5)
		
		spawn_hit_effect(result.position)

func spawn_hit_effect(pos):
	# Create a small red sphere to represent the bullet hole/spark
	var mesh_instance = MeshInstance3D.new()
	var sphere = SphereMesh.new()
	sphere.radius = 0.05
	sphere.height = 0.1
	
	# Create a bright red material
	var mat = StandardMaterial3D.new()
	mat.albedo_color = Color.RED
	mat.emission_enabled = true
	mat.emission = Color.RED
	mat.emission_energy_multiplier = 2.0
	
	mesh_instance.mesh = sphere
	mesh_instance.material_override = mat
	
	# Add to the scene root so it stays in place in the world
	get_tree().root.add_child(mesh_instance)
	mesh_instance.global_position = pos
	
	# Destroy the effect after 2 seconds
	await get_tree().create_timer(2.0).timeout
	if is_instance_valid(mesh_instance):
		mesh_instance.queue_free()

func fire_dig():
	var camera = get_viewport().get_camera_3d()
	if not camera: return
	
	var center_screen = get_viewport().get_visible_rect().size / 2
	var from = camera.project_ray_origin(center_screen)
	var to = from + camera.project_ray_normal(center_screen) * 1000
	var space_state = get_world_3d().direct_space_state
	var query = PhysicsRayQueryParameters3D.create(from, to)
	var result = space_state.intersect_ray(query)
	
	if result:
		var tm = get_terrain_manager()
		if tm:
			# Digging: Add positive value (Air)
			tm.modify_terrain(result.position, 5.0, \"sphere\")
		
		spawn_hit_effect(result.position)

func fire_build(shape=\"sphere\"):
	var camera = get_viewport().get_camera_3d()
	if not camera: return
	
	var center_screen = get_viewport().get_visible_rect().size / 2
	var from = camera.project_ray_origin(center_screen)
	var to = from + camera.project_ray_normal(center_screen) * 1000
	var space_state = get_world_3d().direct_space_state
	var query = PhysicsRayQueryParameters3D.create(from, to)
	var result = space_state.intersect_ray(query)
	
	if result:
		var tm = get_terrain_manager()
		if tm:
			# Building: Subtract negative value (add matter)
			tm.modify_terrain(result.position, -5.0, shape)
		
		spawn_build_effect(result.position)

func spawn_build_effect(pos):
	var mesh_instance = MeshInstance3D.new()
	var sphere = SphereMesh.new()
	sphere.radius = 0.5 # Increased size to be visible
	sphere.height = 1.0
	
	var mat = StandardMaterial3D.new()
	mat.transparency = BaseMaterial3D.TRANSPARENCY_ALPHA
	mat.albedo_color = Color(0, 1, 0, 0.5) # Green ghost effect
	
	mesh_instance.mesh = sphere
	mesh_instance.material_override = mat
	
	# FIX: Added add_child so the mesh actually appears
	get_tree().root.add_child(mesh_instance)
	mesh_instance.global_position = pos

	await get_tree().create_timer(0.5).timeout
	if is_instance_valid(mesh_instance):
		mesh_instance.queue_free()

func place_block():
	var camera = get_viewport().get_camera_3d()
	if not camera: return
	
	var center_screen = get_viewport().get_visible_rect().size / 2
	var from = camera.project_ray_origin(center_screen)
	var to = from + camera.project_ray_normal(center_screen) * 1000
	var space_state = get_world_3d().direct_space_state
	var query = PhysicsRayQueryParameters3D.create(from, to)
	var result = space_state.intersect_ray(query)
	
	if result:
		var pos = result.position + result.normal * 0.5
		var snapped_pos = pos.snapped(Vector3(1, 1, 1))
		
		if BLOCK_SCENE:
			var block = BLOCK_SCENE.instantiate()
			get_tree().root.add_child(block)
			block.global_position = snapped_pos

func remove_block():
	var camera = get_viewport().get_camera_3d()
	if not camera: return
	
	var center_screen = get_viewport().get_visible_rect().size / 2
	var from = camera.project_ray_origin(center_screen)
	var to = from + camera.project_ray_normal(center_screen) * 1000
	var space_state = get_world_3d().direct_space_state
	var query = PhysicsRayQueryParameters3D.create(from, to)
	var result = space_state.intersect_ray(query)
	
	if result and result.collider:
		if result.collider.is_in_group(\"blocks\"):
			result.collider.queue_free()
			spawn_hit_effect(result.position) # Visual feedback
"

[sub_resource type="GDScript" id="GDScript_wc5p8"]
script/source = "extends AudioStreamPlayer3D

# --- CONFIGURATION ---
@export var step_interval: float = 0.5
@export var sound_files: Array[AudioStream] = [
	preload(\"res://sfx/st1-footstep-sfx-323053.mp3\"),
	preload(\"res://sfx/st2-footstep-sfx-323055.mp3\"),
	preload(\"res://sfx/st3-footstep-sfx-323056.mp3\")
]

# Internal variables
var timer: float = 0.0
var parent_player: CharacterBody3D

func _ready():
	# 1. Get the parent node (The Player)
	parent_player = get_parent()
	
	# Safety check: Ensure parent is actually a CharacterBody3D
	if not parent_player is CharacterBody3D:
		set_physics_process(false)
		printerr(\"FootstepComponent must be a child of a CharacterBody3D!\")

func _physics_process(delta):
	# 2. Monitor the parent's state
	
	# We only care about horizontal speed (ignoring gravity/falling speed)
	var horizontal_velocity = Vector2(parent_player.velocity.x, parent_player.velocity.z)
	
	# Check: Is parent on floor? Is parent moving?
	if parent_player.is_on_floor() and horizontal_velocity.length() > 0.1:
		timer -= delta
		if timer <= 0:
			_play_random_sound()
			timer = step_interval
	else:
		# Reset timer so step plays immediately when movement starts
		timer = 0.0

func _play_random_sound():
	if sound_files.is_empty(): return
	
	stream = sound_files.pick_random()
	pitch_scale = randf_range(0.9, 1.1)
	play()
"

[node name="Node3D" type="Node3D"]

[node name="CharacterBody3D4 its a tree" type="CharacterBody3D" parent="."]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 9.442642, 54.100525, 0)
script = SubResource("GDScript_jsk3o")

[node name="Sketchfab_Scene tree" parent="CharacterBody3D4 its a tree" instance=ExtResource("1_wc5p8")]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 0, -23.931396, 0)

[node name="CollisionShape3D" type="CollisionShape3D" parent="CharacterBody3D4 its a tree"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 0, -23.115135, -0.13289416)
shape = SubResource("CapsuleShape3D_wc5p8")

[node name="AudioStreamPlayer" type="AudioStreamPlayer" parent="."]
stream = ExtResource("1_i5arm")
autoplay = true
parameters/looping = true

[node name="WorldEnvironment" type="WorldEnvironment" parent="."]
environment = SubResource("Environment_noarx")

[node name="DirectionalLight3D" type="DirectionalLight3D" parent="."]
transform = Transform3D(-0.8660254, -0.43301278, 0.25, 0, 0.49999997, 0.86602545, -0.50000006, 0.75, -0.43301266, 0, 0, 0)
shadow_enabled = true

[node name="TerrainManager" type="Node3D" parent="." node_paths=PackedStringArray("player")]
script = ExtResource("2_terrain")
chunk_scene = ExtResource("3_chunk")
player = NodePath("../PlayerCharacter3D")

[node name="CharacterBody3D its a zombie" type="CharacterBody3D" parent="."]
transform = Transform3D(6.24, 0, 0, 0, 6.24, 0, 0, 0, 6.24, 0, 106.177025, -3.4154072)
script = SubResource("GDScript_i5arm")

[node name="Sketchfab_Scene zombie" parent="CharacterBody3D its a zombie" instance=ExtResource("3_jka67")]

[node name="CollisionShape3D" type="CollisionShape3D" parent="CharacterBody3D its a zombie"]
transform = Transform3D(0.05, 0, 0, 0, 0.085, 0, 0, 0, 0.01, 0, 0.08586693, 0)
shape = SubResource("CapsuleShape3D_jka67")

[node name="CharacterBody3D2 its a zombie" type="CharacterBody3D" parent="."]
transform = Transform3D(6.24, 0, 0, 0, 6.24, 0, 0, 0, 6.24, 0.667415, 106.177025, -3.4154072)
script = SubResource("GDScript_i5arm")

[node name="Sketchfab_Scene zombie" parent="CharacterBody3D2 its a zombie" instance=ExtResource("3_jka67")]

[node name="CollisionShape3D" type="CollisionShape3D" parent="CharacterBody3D2 its a zombie"]
transform = Transform3D(0.05, 0, 0, 0, 0.085, 0, 0, 0, 0.01, 0, 0.08586693, 0)
shape = SubResource("CapsuleShape3D_jka67")

[node name="CharacterBody3D3 its a zombie" type="CharacterBody3D" parent="."]
transform = Transform3D(6.24, 0, 0, 0, 6.24, 0, 0, 0, 6.24, -0.608122, 106.177025, -3.4154072)
script = SubResource("GDScript_i5arm")

[node name="Sketchfab_Scene zombie" parent="CharacterBody3D3 its a zombie" instance=ExtResource("3_jka67")]

[node name="CollisionShape3D" type="CollisionShape3D" parent="CharacterBody3D3 its a zombie"]
transform = Transform3D(0.05, 0, 0, 0, 0.085, 0, 0, 0, 0.01, 0, 0.08586693, 0)
shape = SubResource("CapsuleShape3D_jka67")

[node name="PlayerCharacter3D" type="CharacterBody3D" parent="."]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 107.50628, 0)
script = ExtResource("1_player")

[node name="MeshInstance3D" type="MeshInstance3D" parent="PlayerCharacter3D"]
mesh = SubResource("CapsuleMesh_noarx")

[node name="CollisionShape3D" type="CollisionShape3D" parent="PlayerCharacter3D"]
shape = SubResource("CapsuleShape3D_a0tk4")

[node name="Camera3D" type="Camera3D" parent="PlayerCharacter3D"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0.49020386, 0)
script = SubResource("GDScript_jka67")

[node name="Sketchfab_Scene" parent="PlayerCharacter3D/Camera3D" instance=ExtResource("4_r3fl7")]
transform = Transform3D(-0.0049240384, 0, 0.0008682415, 0, 0.005, 0, -0.0008682415, 0, -0.0049240384, 0.09346646, -0.09446716, -0.15498024)
script = SubResource("GDScript_r3fl7")

[node name="AudioStreamPlayer3D" type="AudioStreamPlayer3D" parent="PlayerCharacter3D"]
script = SubResource("GDScript_wc5p8")

[node name="CanvasLayer" type="CanvasLayer" parent="PlayerCharacter3D"]

[node name="Control" type="Control" parent="PlayerCharacter3D/CanvasLayer"]
layout_mode = 3
anchors_preset = 0
offset_right = 40.0
offset_bottom = 40.0

[node name="Label" type="Label" parent="PlayerCharacter3D/CanvasLayer/Control"]
layout_mode = 0
offset_right = 40.0
offset_bottom = 23.0
text = "Best game 3 


                             Mouse Controls

Left Mouse: Shoot                       Right Mouse: Nothing

                                    SHIFT:
Left Mouse: Box                         Right Mouse: Road

                                    CTRL:
Left Mouse: Sphere                         Right Mouse: Dig

                                      ALT:
Left Mouse: Place                         Right Mouse: Remove"
